\section{Implementation of Asynchronous Read}
\subsection{XDR}
We generated the request and response structures for our asynchronous read using the External Data Representation (XDR) \cite{XDR}. External Data Representation (XDR) is a standard data serialization format. XDR allows the data to be transferred seamlessly between different kinds of systems. Let us now look at each of these structures in detail.

\begin{lstlisting}
struct ASYNC_READ4args{
	uint64_t  reqId; 
	stateid4  stateid; 
	offset4	  offset; 
	count4	  count;
	uint32_t  timeout; 
};
\end{lstlisting}

\noindent\textit{ASYNC\_READ4args} : The client sends these argument structure as part of the initial request to the server. Detailed explanation of the arguments in \textit{ASYNC\_READ4args} will follow. 
\hfill \break \newline
\noindent\textit{reqId} : Reqid is a 64 bit integer, generated by the client. This is generated based on the requested \textit{filehandle}, processId/threadId and current\_timestamp and will uniquely identify every request. The server passes the same request id to the client as part of the callback along with the requested file data. The client process/thread then uses this  \textit{reqId} to uniquely identify the request among multiple requests that it might have triggered to the server. Note that \textit{reqId} is opaque to the server.
\hfill \break \newline
\noindent\textit{stateid} : Stateid is a 128-bit quantity returned by a server in the initial open request. It uniquely defines the open and locking state provided by the server for a specific open or lock owner for a specific file. We are using \textit{stateid} on the server side to check the client share/delegation access on the requested file. 
\hfill \break \newline
\noindent\textit{offset} : Offset (from the start of the file) at which the read has to start in the file. 
\hfill \break \newline
\noindent\textit{count}: Number of bytes to read from the requested file.
\hfill \break \newline
\noindent\textit{timeout}: \textit{timeout} is a configurable feild in milliseconds. This feild specifies the maximum time that the server can take to respond with a callback once it recievies the asynchronous read request. This feild is important for the client to identify server crashes and any network outages. If the client doesn't recieve the response in the specified time, it treats the request as a failure and resends the request.     
\hfill \break \newline
\noindent On receiving the request from the client, the server performs the initial checks. Then the server responds with \textsc{ASYNC\_READ4res} to the client. Now we will explain the status passed as part of \textsc{ASYNC\_READ4res} to the client.  

\begin{lstlisting}
struct ASYNC_READ4res{
	nfsstat4	  status;
};
\end{lstlisting}

\textit{status} : Indicates the status corresponding to initial permission checks on the requested file.
On receiving the asynchronous read request on the server side, we are checking the client's share/delegation on the requested file. On success we will return \textsc{nfs4\_ok}.  If the checks fail, we are returning appropriate error status.
\hfill \break \newline
\noindent Let us now understand the structure used by the server when making a callback to the client. The server passes \textit{CB\_ASYNC\_READ4args} as part of the request to the client. We will now look at each of the arguments in detail. 
\begin{lstlisting}
union CB_ASYNC_READ4args 
	switch(nfsstat4 status){
	case NFS4_OK:
	 CB_ASYNC_READ4argsok argok4;
 	default:
		void;
};
\end{lstlisting}

\noindent The first argument in the callback request to the client is the status. If the data is fetched successfully from the local file system, the status will be \textsc{nfs4\_ok} . In case of an error, an appropriate error status will be sent to the client. If the data is fetched successfully, a second argument of type \textit{CB\_ASYNC\_READ4argsok} will also be passed in the callback to the client. Otherwise, only status will be passed. A detailed explanation of each of the fields in \textit{CB\_ASYNC\_READ4argsok} will follow.

\begin{lstlisting}
struct CB_ASYNC_READ4argsok{
	uint64_t	 reqId;
	bool		 eof;
	opaque	data<>;
};
\end{lstlisting}

\noindent\textit{reqId}: The \textit{reqId} received by the server from the client during the initial asynchronous read request. This is used by the client to identify the owner of the request.
\hfill \break \newline
\noindent\textit{eof} : A boolean value indicating if the end of the file has been reached.
\hfill \break \newline
\noindent\textit{data} : Requested file data.
\hfill \break \newline
\noindent On receiving the callback request from the server, client forwards the data to the respective owner based on the \textit{reqId}. Then the client responds with \textit{CB\_ASYNC\_READ4res} to the server.
 
\begin{lstlisting}
struct CB_ASYNC_READ4res{
	nfsstat4	 status;
};
\end{lstlisting}

\noindent\textit{status} : Indicates the asynchronous read callback status from the client. On success, status will be \textsc{nfs4\_ok} else the corresponding error message will be passed to the server.



We will now discuss the existing implementation of \textsc{NFS\_READ} in NFS Ganesha. Understanding \textsc{NFS\_READ} is important as we have reused the design of \textsc{NFS\_READ} for performing actual read during callback in asynchronous read operation.


\subsection{Implementation of NFS Read in Pynfs Client}
 
In \textsc{NFSv4.0} and above, all the nfs operation are performed using compounds. Compound can consist of multiple requests. So, for performing the read operation, the client will prepare a nfs4\_compound request consisting of two operations.The first operation is the \textsc{PUTFH}, which  basically updates the current file handle to the file handle on which the client intends to perform the read. The other operation is the actual read operation, which basically reads a content from a specified file from the given offset. The read operation takes three arguments as input, the first argument is the  \textsc{stateid}. The state id helps the server to check the client access on the requested file. The client usually obtains the \textsc{stateid} in response for the open file request.The second  argument is the offset, which specifies the server the location from where the read should start. The last argument specifies number of bytes to read from the given offset.The client will then initiate the nfs read request. It will then traverse through the RPC layer and gets encoded in the XDR layer for sending on the network.

\begin{figure*}
\centering
\includegraphics[scale=0.7]{figures/AsyncRead.eps}
\caption{NFS Asynchronous Read Architecture Diagram}
\label{fig:NFSAsyncReadArch}
\end{figure*}

\subsection{Implementation of NFS Read in Pynfs Server}


\subsection{Implementation NFS Read in NFS-Ganesha}

 As we have mentioned in the previous sections, the request processing in NFS Ganesha is done by pthreads. Figure~\ref{fig:NFSReadArch} depicts the architecture diagram of \textsc{NFS\_Read} in NFS Ganesha. The server on receiving the incoming read request, it will notify the dispatcher threads for decoding the request. The dispatcher thread will decode the request and enqueue the worker queue for processing of the request. One of the worker thread will dequeue the request from the worker queue and process it. The processing of a read request involves validating the client access on the requested file.On success, the worker thread will perform a file system/cache read for getting the requested data. Once the server has retrieved the data successfully from the underlying file system, it will then send the response back to the client with the requested data.
 
\subsection{Implementation of NFS Async Read in Pynfs Client}
 
  The client side operations for asynchronous read are similar to read. The only difference is here we will \textsc{asynread} request in the nfs4\_compound instead of read request. The asynchronous read request takes four argument as input. In the current implementation of asynchronous read it only takes one extra argument compared to read that is the \textsc{requestid}. have to write about reqID.
  
\subsection{Implementation of NFS Async Read in Pynfs Server}
  
\subsection{Implementation NFS Async Read in NFS-Ganesha}  

 Figure~\ref{fig:NFSAsyncReadArch} depicts the architecture diagram of \textsc{NFS\_ASYNCRead} in NFS Ganesha. The server on receiving the incoming asynchronous read request, it will notify the dispatcher threads for decoding the request. The dispatcher thread will decode the request and enqueue the worker queue for processing of the request. One of the worker thread will dequeue the request from the worker queue and process it. The processing of asynchronous read request involves preparing of an new nfs-request for the callback and then enqueue the request in worker queue. Immediately after the enqueue operation is successful the worker thread will respond to the client using \textsc{NFS4\_OK}.On receiving the initial response, client is not blocked any more and is free to perform further tasks. On the server side any other worker thread which is waiting on the worker queue for processing the new requests will the dequeue this new request and process it. This involves performing all the necessary checks like the \textsc{stateid} validation and read access validation. Once all the checks are passed the worker thread will perform the actual file system read/cache read depending on the presence of data. After reading the data the worker thread will prepare a callback request and perform the callback operation using \textsc{cb\_async\_read} operation. The callback request can be sent in two ways. One is the worker thread which has performed the actual read can sent the request and the other way is this worker thread can enqueue the callback request. Any other worker thread which is waiting on the worker queue will pick this request and identifies the request type as a \textsc{NFS\_CALL} and then performs the dispatch call operation for dispatching the callback to the client. 
 
 






 
 
 








